<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>src.text.visualizer.result_visualizer.result_aggregator API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.text.visualizer.result_visualizer.result_aggregator</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.text.visualizer.result_visualizer.result_aggregator.coloring"><code class="name flex">
<span>def <span class="ident">coloring</span></span>(<span>method_name: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coloring(method_name: str) -&gt; str:
    &#34;&#34;&#34;
    Coloring function for the methods after renaming.
    &#34;&#34;&#34;
    if &#34;V-GAN&#34; in method_name:
        return colors.VGAN_GREEN
    elif FEATURE_BAGGING in method_name or &#34;FB&#34; in method_name:
        return colors.TRIADIC[0]
    else:
        return colors.TRIADIC[1]</code></pre>
</details>
<div class="desc"><p>Coloring function for the methods after renaming.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator"><code class="flex name class">
<span>class <span class="ident">ResultAggregator</span></span>
<span>(</span><span>version_path: pathlib.Path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResultAggregator():

    def __init__(self, version_path: Path):
        &#34;&#34;&#34;
        Initializes the ResultAggregator with the path to the version directory. This class will traverse the nested
        directory structure to find all the results stored in the subfolders. The results are expected to be in CSV format.
        Computes the average over the runs and stores the results in a new CSV file in the version directory.
        :param version_path: The path to the version directory. This should be the base directory where the results are
            stored in the subfolder structure.
        &#34;&#34;&#34;
        self.version_path = version_path
        assert self.version_path.exists(), f&#34;Version path {self.version_path} does not exist.&#34;

    def aggregate(self):
        &#34;&#34;&#34;
        Aggregates the results from the subfolders in the version directory. This method will traverse the directory
        structure, find all the CSV files, and compute the average over the runs. The results are stored in a new CSV
        file in the version directory. The folder structure is expected to be as follows: version_path / [datasets] / [models] / run_[0..n] / result.csv
        &#34;&#34;&#34;

        result_dfs = []

        # Traverse the directory structure to find all the CSV files
        for dataset_path in self.version_path.iterdir():
            if not dataset_path.is_dir():
                continue
            for model_path in dataset_path.iterdir():
                if not model_path.is_dir():
                    continue
                for run_path in model_path.iterdir():
                    if not run_path.is_dir() or not run_path.name.startswith(&#34;run_&#34;):
                        continue

                    result_file = run_path / &#34;results.csv&#34;

                    model_name = model_path.name
                    dataset_name = dataset_path.name

                    if result_file.exists():
                        # Read the CSV file and compute the average over the runs
                        df = pd.read_csv(result_file)

                        df[EMB_MODEL_COL] = model_name
                        df[DATASET_COL] = dataset_name

                        result_dfs.append(df)

        group_by_columns = [METHOD_COL, SPACE_COL, BASE_COL, DATASET_COL, EMB_MODEL_COL]

        df = pd.concat(result_dfs, ignore_index=True)

        df = df[df[SPACE_COL] != &#34;Word avg&#34;]

        # Only include methods present in all runs
        amount_runs = len(result_dfs)
        included_methods = []
        for method in df[METHOD_COL].unique():
            present_in = len(df[df[METHOD_COL] == method].index)
            if present_in + 10 &gt; amount_runs:
                included_methods.append(method)
            #else:
                #print(f&#34;{method} not present in all runs ({present_in} / {amount_runs}).&#34;)

        # Include only the methods present in all runs or if the name contains &#34;TextVMMD&#34;
        df = df[df[METHOD_COL].isin(included_methods) | df[METHOD_COL].str.contains(&#34;TextVMMD&#34;)]

        # Average over the runs
        avg_df: pd.DataFrame = df.groupby(group_by_columns).mean().reset_index()

        # Group by dataset and create rankings from the average AUC, where the best AUC is ranked 1
        avg_df[RANK_COL] = avg_df.groupby(DATASET_COL)[AUC_COL].rank(ascending=False, method=&#39;first&#39;)
        ranked_df = avg_df.sort_values(by=[DATASET_COL, AUC_COL], ascending=[True, False])

        export_path = self.version_path / &#34;ranked_results_filtered.csv&#34;
        ranked_df.to_csv(export_path, index=False)
        df.to_csv(self.version_path / &#34;non_aggregated.csv&#34;, index=False)
        self._create_rank_plot(ranked_df, group_by=BASE_COL)

        ranked_df[METHOD_COL] = ranked_df[METHOD_COL].apply(self.rename)
        ranked_df[SPACE_COL] = ranked_df[SPACE_COL].replace(&#34;Embedding&#34;, &#34;Avg&#34;).replace(&#34;Token-space&#34;, &#34;Avg&#34;).replace(&#34;Word NPTE&#34;, &#34;NPTE&#34;)
        ranked_df.to_csv(self.version_path / &#34;ranked_results_filterd_renamed.csv&#34;, index=False)

        self._create_rank_plot(ranked_df, group_by=[BASE_COL, SPACE_COL] , name=&#34;ranked_renamed&#34;, method_color=coloring)
        return
        rank = RankVisualizer([], self.version_path)
        rank.create_box_plot_vertical(data=ranked_df,
                                      method_col=METHOD_COL,
                                      metric_col=AUC_COL,
                                      group_by=[BASE_COL, SPACE_COL],
                                      method_color=coloring, name=&#34;ranked_renamed_vertical&#34;)

    def rename(self, method_name: str) -&gt; str:
        #if method_name.endswith(&#34;+ Embedding&#34;):
        method_name = method_name.replace(&#34;+ Embedding&#34;, AVG_SPACE)

        method_name = method_name.replace(&#34;+ Word NPTE&#34;, &#34;NPTE&#34;)

        if method_name.startswith(&#34;FeatureBagging&#34;):
            method_name = FEATURE_BAGGING# + &#34; &#34; + method_name.split(&#34; &#34;)[-1]
            return method_name

        if method_name.startswith(&#34;VMMD&#34;):# and &#34;E&#34; in method_name:
            return V_GAN

        #if method_name.startswith(&#34;VMMD&#34;) and &#34;W&#34; in method_name:
            #return V_GAN_NPTE

        if method_name.startswith(&#34;TokenVMMD&#34;):
            return V_GAN_TOKEN

        if method_name.startswith(&#34;TextVMMD&#34;):
            return V_GAN_TEXT

        if method_name == TRIVIAL:
            return TRIVIAL

        return FULL_SPACE# + &#34; &#34; + method_name.split(&#34; &#34;)[-1]


    def _create_rank_plot(self, ranked_df, group_by: str or list, name:Optional[str] = None, method_color: Optional[Callable[[str], str]] = None):
        &#34;&#34;&#34;
        Creates a box plot of the ranks for each method and metric, grouped by base method.
        &#34;&#34;&#34;

        rank_visualizer = RankVisualizer([], self.version_path)
        rank_visualizer.create_box_plot(data=ranked_df,
                                        method_col=METHOD_COL,
                                        metric_col=AUC_COL,
                                        group_by=group_by, name=name, method_color=method_color)</code></pre>
</details>
<div class="desc"><p>Initializes the ResultAggregator with the path to the version directory. This class will traverse the nested
directory structure to find all the results stored in the subfolders. The results are expected to be in CSV format.
Computes the average over the runs and stores the results in a new CSV file in the version directory.
:param version_path: The path to the version directory. This should be the base directory where the results are
stored in the subfolder structure.</p></div>
<h3>Methods</h3>
<dl>
<dt id="src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator.aggregate"><code class="name flex">
<span>def <span class="ident">aggregate</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregate(self):
    &#34;&#34;&#34;
    Aggregates the results from the subfolders in the version directory. This method will traverse the directory
    structure, find all the CSV files, and compute the average over the runs. The results are stored in a new CSV
    file in the version directory. The folder structure is expected to be as follows: version_path / [datasets] / [models] / run_[0..n] / result.csv
    &#34;&#34;&#34;

    result_dfs = []

    # Traverse the directory structure to find all the CSV files
    for dataset_path in self.version_path.iterdir():
        if not dataset_path.is_dir():
            continue
        for model_path in dataset_path.iterdir():
            if not model_path.is_dir():
                continue
            for run_path in model_path.iterdir():
                if not run_path.is_dir() or not run_path.name.startswith(&#34;run_&#34;):
                    continue

                result_file = run_path / &#34;results.csv&#34;

                model_name = model_path.name
                dataset_name = dataset_path.name

                if result_file.exists():
                    # Read the CSV file and compute the average over the runs
                    df = pd.read_csv(result_file)

                    df[EMB_MODEL_COL] = model_name
                    df[DATASET_COL] = dataset_name

                    result_dfs.append(df)

    group_by_columns = [METHOD_COL, SPACE_COL, BASE_COL, DATASET_COL, EMB_MODEL_COL]

    df = pd.concat(result_dfs, ignore_index=True)

    df = df[df[SPACE_COL] != &#34;Word avg&#34;]

    # Only include methods present in all runs
    amount_runs = len(result_dfs)
    included_methods = []
    for method in df[METHOD_COL].unique():
        present_in = len(df[df[METHOD_COL] == method].index)
        if present_in + 10 &gt; amount_runs:
            included_methods.append(method)
        #else:
            #print(f&#34;{method} not present in all runs ({present_in} / {amount_runs}).&#34;)

    # Include only the methods present in all runs or if the name contains &#34;TextVMMD&#34;
    df = df[df[METHOD_COL].isin(included_methods) | df[METHOD_COL].str.contains(&#34;TextVMMD&#34;)]

    # Average over the runs
    avg_df: pd.DataFrame = df.groupby(group_by_columns).mean().reset_index()

    # Group by dataset and create rankings from the average AUC, where the best AUC is ranked 1
    avg_df[RANK_COL] = avg_df.groupby(DATASET_COL)[AUC_COL].rank(ascending=False, method=&#39;first&#39;)
    ranked_df = avg_df.sort_values(by=[DATASET_COL, AUC_COL], ascending=[True, False])

    export_path = self.version_path / &#34;ranked_results_filtered.csv&#34;
    ranked_df.to_csv(export_path, index=False)
    df.to_csv(self.version_path / &#34;non_aggregated.csv&#34;, index=False)
    self._create_rank_plot(ranked_df, group_by=BASE_COL)

    ranked_df[METHOD_COL] = ranked_df[METHOD_COL].apply(self.rename)
    ranked_df[SPACE_COL] = ranked_df[SPACE_COL].replace(&#34;Embedding&#34;, &#34;Avg&#34;).replace(&#34;Token-space&#34;, &#34;Avg&#34;).replace(&#34;Word NPTE&#34;, &#34;NPTE&#34;)
    ranked_df.to_csv(self.version_path / &#34;ranked_results_filterd_renamed.csv&#34;, index=False)

    self._create_rank_plot(ranked_df, group_by=[BASE_COL, SPACE_COL] , name=&#34;ranked_renamed&#34;, method_color=coloring)
    return
    rank = RankVisualizer([], self.version_path)
    rank.create_box_plot_vertical(data=ranked_df,
                                  method_col=METHOD_COL,
                                  metric_col=AUC_COL,
                                  group_by=[BASE_COL, SPACE_COL],
                                  method_color=coloring, name=&#34;ranked_renamed_vertical&#34;)</code></pre>
</details>
<div class="desc"><p>Aggregates the results from the subfolders in the version directory. This method will traverse the directory
structure, find all the CSV files, and compute the average over the runs. The results are stored in a new CSV
file in the version directory. The folder structure is expected to be as follows: version_path / [datasets] / [models] / run_[0..n] / result.csv</p></div>
</dd>
<dt id="src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, method_name: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self, method_name: str) -&gt; str:
    #if method_name.endswith(&#34;+ Embedding&#34;):
    method_name = method_name.replace(&#34;+ Embedding&#34;, AVG_SPACE)

    method_name = method_name.replace(&#34;+ Word NPTE&#34;, &#34;NPTE&#34;)

    if method_name.startswith(&#34;FeatureBagging&#34;):
        method_name = FEATURE_BAGGING# + &#34; &#34; + method_name.split(&#34; &#34;)[-1]
        return method_name

    if method_name.startswith(&#34;VMMD&#34;):# and &#34;E&#34; in method_name:
        return V_GAN

    #if method_name.startswith(&#34;VMMD&#34;) and &#34;W&#34; in method_name:
        #return V_GAN_NPTE

    if method_name.startswith(&#34;TokenVMMD&#34;):
        return V_GAN_TOKEN

    if method_name.startswith(&#34;TextVMMD&#34;):
        return V_GAN_TEXT

    if method_name == TRIVIAL:
        return TRIVIAL

    return FULL_SPACE# + &#34; &#34; + method_name.split(&#34; &#34;)[-1]</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.text.visualizer.result_visualizer" href="index.html">src.text.visualizer.result_visualizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.text.visualizer.result_visualizer.result_aggregator.coloring" href="#src.text.visualizer.result_visualizer.result_aggregator.coloring">coloring</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator" href="#src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator">ResultAggregator</a></code></h4>
<ul class="">
<li><code><a title="src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator.aggregate" href="#src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator.aggregate">aggregate</a></code></li>
<li><code><a title="src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator.rename" href="#src.text.visualizer.result_visualizer.result_aggregator.ResultAggregator.rename">rename</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
