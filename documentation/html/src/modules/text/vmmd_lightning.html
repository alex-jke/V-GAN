<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>src.modules.text.vmmd_lightning API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.modules.text.vmmd_lightning</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.modules.text.vmmd_lightning.VMMDLightningBase"><code class="flex name class">
<span>class <span class="ident">VMMDLightningBase</span></span>
<span>(</span><span>embedding: Callable[[numpy.ndarray[str], int, torch.Tensor | None], torch.Tensor] | None = None,<br>batch_size=500,<br>epochs=500,<br>lr=0.0001,<br>seed=777,<br>weight_decay=0.0001,<br>path_to_directory=None,<br>weight=0,<br>generator=None,<br>print_updates=False,<br>gradient_clipping=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VMMDLightningBase(pl.LightningModule, IVMMDBase):
    def __init__(self,
                 embedding: Optional[Callable[[np.ndarray[str], int, Optional[Tensor]], Tensor]] = None,
                 batch_size=500, epochs=500, lr=1e-4, seed=777,
                 weight_decay=1e-4, path_to_directory=None, weight=0, generator=None,
                 print_updates=False, gradient_clipping=False):
        super().__init__()
        self.save_hyperparameters()  # Save hyperparameters in Lightning
        self.train_history = defaultdict(list)
        self.generator_loss_key = &#34;generator_loss&#34;
        self.mmd_loss_key = &#34;mmd_loss&#34;
        self.gradient_key = &#34;gradient&#34;
        self.batch_size = batch_size
        self.epochs = epochs
        self.lr = lr
        self.seed = seed if seed is not None else np.random.randint(10, 10000, 1)
        self.provided_generator = generator if generator is not None else GeneratorSigmoidSTE
        self.weight_decay = weight_decay
        self.path_to_directory = path_to_directory
        self.generator_optimizer = None
        self.embedding = embedding
        self.weight = weight
        self.print_updates = print_updates
        self.apply_gradient_clipping = gradient_clipping
        self._latent_size = None
        seed_everything(self.seed)
        torch.set_float32_matmul_precision(&#39;high&#39;)
        self.recommended_bandwidth_name = &#34;recommended bandwidth&#34;

    def _create_plot(self):
        train_df = pd.read_csv(Path(self.path_to_directory) / &#34;lightning_logs&#34; / &#34;version_0&#34; / &#34;metrics.csv&#34;)
        self.train_history = train_df.groupby(&#34;epoch&#34;).mean().reset_index()
        self._plot_gradients()
        generator_y = self.train_history[self.generator_loss_key]
        mmd_y = self.train_history[self.mmd_loss_key]
        x = np.linspace(1, len(generator_y), len(generator_y))
        fig, ax1 = plt.subplots()
        ax1.plot(x, generator_y, color=VGAN_GREEN, label=&#34;Generator loss&#34;, linewidth=2)
        ax1.set_xlabel(&#34;Epoch&#34;)
        ax1.set_ylabel(&#34;Generator Loss&#34;, color=VGAN_GREEN)
        ax1.tick_params(axis=&#39;y&#39;, labelcolor=VGAN_GREEN)
        ax2 = ax1.twinx()
        ax2.plot(x, mmd_y, color=COMPLIMENTARY, label=&#34;MMD loss&#34;, linewidth=2)
        ax2.set_ylabel(&#34;MMD Loss&#34;, color=COMPLIMENTARY)
        ax2.tick_params(axis=&#39;y&#39;, labelcolor=COMPLIMENTARY)
        lines1, labels1 = ax1.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(lines1 + lines2, labels1 + labels2, loc=&#34;upper right&#34;)
        fig.tight_layout()
        return plt, ax1


    def model_snapshot(self, path_to_directory=None, x_data: Optional[np.ndarray[str]] = None):
        self._plot_loss(path_to_directory, x_data)


    def load_models(self, path_to_generator, ndims, device=None):
        if device is None:
            device = self.device()
        self.generator = self.get_the_networks(ndims, latent_size=max(int(ndims / 16), 1)).to(device)
        self.generator.load_state_dict(torch.load(path_to_generator, map_location=device))
        self.generator.eval()
        self.generator_optimizer = f&#39;Loaded Model from {path_to_generator} with {ndims} dimensions&#39;
        self._latent_size = max(int(ndims / 16), 1)

    def generate_subspaces(self, nsubs, round=True):
        if self._latent_size is None:
            raise RuntimeError(&#39;Latent size not set.&#39;)
        noise_tensor = torch.Tensor(nsubs, self._latent_size).to(&#39;cpu&#39;)
        torch.manual_seed(self.seed)
        noise_tensor.normal_()
        self.generator = self.generator.to(self.device())
        noise_tensor = noise_tensor.to(self.device())
        u = self.generator(noise_tensor)
        if round:
            u = (u &gt;= 0.5).int()
        return u.detach()

    def _get_data_loader(self, data: np.array):
        num_workers = 0
        pin_memory = torch.cuda.is_available() or torch.backends.mps.is_available()
        return DataLoader(
            data, batch_size=self.batch_size, drop_last=True, pin_memory=pin_memory,
            shuffle=True, num_workers=num_workers, persistent_workers=False
        )

    def _get_noise_tensor(self, latent_size: int):
        if torch.cuda.is_available():
            return torch.FloatTensor(self.batch_size, latent_size).to(&#34;cuda&#34;)
        elif torch.backends.mps.is_available():
            return torch.FloatTensor(self.batch_size, latent_size).to(torch.device(&#39;mps&#39;))
        else:
            return torch.FloatTensor(self.batch_size, latent_size)

    def _export(self, generator, export_params=True, export_path: Optional[str] = None,
                x_data: Optional[ndarray[str]] = None):
        path = self.path_to_directory

        if path is None:
            path = export_path
            self.path_to_directory = path

        if path is not None:
            path_to_directory = Path(path)
            if not path_to_directory.exists():
                os.makedirs(path_to_directory)
            models_dir = path_to_directory / &#39;models&#39;
            if not models_dir.exists():
                os.mkdir(models_dir)
            run_number = int(len(os.listdir(models_dir)))
            if export_params:
                torch.save(generator.state_dict(), models_dir / f&#39;generator_{run_number}.pt&#39;)
            self.model_snapshot(path_to_directory, x_data)

    def device(self) -&gt; torch.device:
        return torch.device(&#39;cuda&#39; if torch.cuda.is_available()
                            else (&#34;mps&#34; if torch.backends.mps.is_available() else &#34;cpu&#34;))

    # The following methods must be implemented in subclasses:
    def training_step(self, batch, batch_idx):
        raise NotImplementedError(&#34;Define training_step in subclass.&#34;)

    def configure_optimizers(self):
        raise NotImplementedError(&#34;Define configure_optimizers in subclass.&#34;)</code></pre>
</details>
<div class="desc"><p>Hooks to be used in LightningModule.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytorch_lightning.core.module.LightningModule</li>
<li>lightning_fabric.utilities.device_dtype_mixin._DeviceDtypeModuleMixin</li>
<li>pytorch_lightning.core.mixins.hparams_mixin.HyperparametersMixin</li>
<li>pytorch_lightning.core.hooks.ModelHooks</li>
<li>pytorch_lightning.core.hooks.DataHooks</li>
<li>pytorch_lightning.core.hooks.CheckpointHooks</li>
<li>torch.nn.modules.module.Module</li>
<li>i_vmmd_base.IVMMDBase</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.modules.text.vmmd_lightning.VMMDLightningBase.configure_optimizers"><code class="name flex">
<span>def <span class="ident">configure_optimizers</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_optimizers(self):
    raise NotImplementedError(&#34;Define configure_optimizers in subclass.&#34;)</code></pre>
</details>
<div class="desc"><p>Choose what optimizers and learning-rate schedulers to use in your optimization. Normally you'd need one.
But in the case of GANs or similar you might have multiple. Optimization with multiple optimizers only works in
the manual optimization mode.</p>
<h2 id="return">Return</h2>
<p>Any of these 6 options.</p>
<ul>
<li><strong>Single optimizer</strong>.</li>
<li><strong>List or Tuple</strong> of optimizers.</li>
<li><strong>Two lists</strong> - The first list has multiple optimizers, and the second has multiple LR schedulers
(or multiple <code>lr_scheduler_config</code>).</li>
<li><strong>Dictionary</strong>, with an <code>"optimizer"</code> key, and (optionally) a <code>"lr_scheduler"</code>
key whose value is a single LR scheduler or <code>lr_scheduler_config</code>.</li>
<li><strong>None</strong> - Fit will run without any optimizer.</li>
</ul>
<p>The <code>lr_scheduler_config</code> is a dictionary which contains the scheduler and its associated configuration.
The default configuration is shown below.</p>
<p>.. code-block:: python</p>
<pre><code>lr_scheduler_config = {
    # REQUIRED: The scheduler instance
    "scheduler": lr_scheduler,
    # The unit of the scheduler's step size, could also be 'step'.
    # 'epoch' updates the scheduler on epoch end whereas 'step'
    # updates it after a optimizer update.
    "interval": "epoch",
    # How many epochs/steps should pass between calls to
    # &lt;code&gt;scheduler.step()&lt;/code&gt;. 1 corresponds to updating the learning
    # rate after every epoch/step.
    "frequency": 1,
    # Metric to monitor for schedulers like &lt;code&gt;ReduceLROnPlateau&lt;/code&gt;
    "monitor": "val_loss",
    # If set to &lt;code&gt;True&lt;/code&gt;, will enforce that the value specified 'monitor'
    # is available when the scheduler is updated, thus stopping
    # training if not found. If set to &lt;code&gt;False&lt;/code&gt;, it will only produce a warning
    "strict": True,
    # If using the &lt;code&gt;LearningRateMonitor&lt;/code&gt; callback to monitor the
    # learning rate progress, this keyword can be used to specify
    # a custom logged name
    "name": None,
}
</code></pre>
<p>When there are schedulers in which the <code>.step()</code> method is conditioned on a value, such as the
:class:<code>torch.optim.lr_scheduler.ReduceLROnPlateau</code> scheduler, Lightning requires that the
<code>lr_scheduler_config</code> contains the keyword <code>"monitor"</code> set to the metric name that the scheduler
should be conditioned on.</p>
<div class="admonition testcode">
<p class="admonition-title">Testcode</p>
<h1 id="the-reducelronplateau-scheduler-requires-a-monitor">The ReduceLROnPlateau scheduler requires a monitor</h1>
<p>def configure_optimizers(self):
optimizer = Adam(&hellip;)
return {
"optimizer": optimizer,
"lr_scheduler": {
"scheduler": ReduceLROnPlateau(optimizer, &hellip;),
"monitor": "metric_to_track",
"frequency": "indicates how often the metric is updated",
# If "monitor" references validation metrics, then "frequency" should be set to a
# multiple of "trainer.check_val_every_n_epoch".
},
}</p>
<h1 id="in-the-case-of-two-optimizers-only-one-using-the-reducelronplateau-scheduler">In the case of two optimizers, only one using the ReduceLROnPlateau scheduler</h1>
<p>def configure_optimizers(self):
optimizer1 = Adam(&hellip;)
optimizer2 = SGD(&hellip;)
scheduler1 = ReduceLROnPlateau(optimizer1, &hellip;)
scheduler2 = LambdaLR(optimizer2, &hellip;)
return (
{
"optimizer": optimizer1,
"lr_scheduler": {
"scheduler": scheduler1,
"monitor": "metric_to_track",
},
},
{"optimizer": optimizer2, "lr_scheduler": scheduler2},
)</p>
</div>
<p>Metrics can be made available to monitor by simply logging it using
<code>self.log('metric_to_track', metric_val)</code> in your :class:<code>~pytorch_lightning.core.LightningModule</code>.</p>
<h2 id="note">Note</h2>
<p>Some things to know:</p>
<ul>
<li>Lightning calls <code>.backward()</code> and <code>.step()</code> automatically in case of automatic optimization.</li>
<li>If a learning rate scheduler is specified in <code>configure_optimizers()</code> with key
<code>"interval"</code> (default "epoch") in the scheduler configuration, Lightning will call
the scheduler's <code>.step()</code> method automatically in case of automatic optimization.</li>
<li>If you use 16-bit precision (<code>precision=16</code>), Lightning will automatically handle the optimizer.</li>
<li>If you use :class:<code>torch.optim.LBFGS</code>, Lightning handles the closure function automatically for you.</li>
<li>If you use multiple optimizers, you will have to switch to 'manual optimization' mode and step them
yourself.</li>
<li>If you need to control how often the optimizer steps, override the :meth:<code>optimizer_step</code> hook.</li>
</ul></div>
</dd>
<dt id="src.modules.text.vmmd_lightning.VMMDLightningBase.device"><code class="name flex">
<span>def <span class="ident">device</span></span>(<span>self) ‑> torch.device</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device(self) -&gt; torch.device:
    return torch.device(&#39;cuda&#39; if torch.cuda.is_available()
                        else (&#34;mps&#34; if torch.backends.mps.is_available() else &#34;cpu&#34;))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="src.modules.text.vmmd_lightning.VMMDLightningBase.generate_subspaces"><code class="name flex">
<span>def <span class="ident">generate_subspaces</span></span>(<span>self, nsubs, round=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_subspaces(self, nsubs, round=True):
    if self._latent_size is None:
        raise RuntimeError(&#39;Latent size not set.&#39;)
    noise_tensor = torch.Tensor(nsubs, self._latent_size).to(&#39;cpu&#39;)
    torch.manual_seed(self.seed)
    noise_tensor.normal_()
    self.generator = self.generator.to(self.device())
    noise_tensor = noise_tensor.to(self.device())
    u = self.generator(noise_tensor)
    if round:
        u = (u &gt;= 0.5).int()
    return u.detach()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="src.modules.text.vmmd_lightning.VMMDLightningBase.load_models"><code class="name flex">
<span>def <span class="ident">load_models</span></span>(<span>self, path_to_generator, ndims, device=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_models(self, path_to_generator, ndims, device=None):
    if device is None:
        device = self.device()
    self.generator = self.get_the_networks(ndims, latent_size=max(int(ndims / 16), 1)).to(device)
    self.generator.load_state_dict(torch.load(path_to_generator, map_location=device))
    self.generator.eval()
    self.generator_optimizer = f&#39;Loaded Model from {path_to_generator} with {ndims} dimensions&#39;
    self._latent_size = max(int(ndims / 16), 1)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="src.modules.text.vmmd_lightning.VMMDLightningBase.model_snapshot"><code class="name flex">
<span>def <span class="ident">model_snapshot</span></span>(<span>self, path_to_directory=None, x_data: numpy.ndarray[str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_snapshot(self, path_to_directory=None, x_data: Optional[np.ndarray[str]] = None):
    self._plot_loss(path_to_directory, x_data)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="src.modules.text.vmmd_lightning.VMMDLightningBase.training_step"><code class="name flex">
<span>def <span class="ident">training_step</span></span>(<span>self, batch, batch_idx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def training_step(self, batch, batch_idx):
    raise NotImplementedError(&#34;Define training_step in subclass.&#34;)</code></pre>
</details>
<div class="desc"><p>Here you compute and return the training loss and some additional metrics for e.g. the progress bar or
logger.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>batch</code></strong></dt>
<dd>The output of your data iterable, normally a :class:<code>~torch.utils.data.DataLoader</code>.</dd>
<dt><strong><code>batch_idx</code></strong></dt>
<dd>The index of this batch.</dd>
<dt><strong><code>dataloader_idx</code></strong></dt>
<dd>The index of the dataloader that produced this batch.
(only if multiple dataloaders used)</dd>
</dl>
<h2 id="return">Return</h2>
<ul>
<li>:class:<code>~torch.Tensor</code> - The loss tensor</li>
<li><code>dict</code> - A dictionary which can include any keys, but must include the key <code>'loss'</code> in the case of
automatic optimization.</li>
<li><code>None</code> - In automatic optimization, this will skip to the next batch (but is not supported for
multi-GPU, TPU, or DeepSpeed). For manual optimization, this has no special meaning, as returning
the loss is not required.</li>
</ul>
<p>In this step you'd normally do the forward pass and calculate the loss for a batch.
You can also do fancier things like multiple forward passes or something model specific.</p>
<p>Example::</p>
<pre><code>def training_step(self, batch, batch_idx):
    x, y, z = batch
    out = self.encoder(x)
    loss = self.loss(out, x)
    return loss
</code></pre>
<p>To use multiple optimizers, you can switch to 'manual optimization' and control their stepping:</p>
<p>.. code-block:: python</p>
<pre><code>def __init__(self):
    super().__init__()
    self.automatic_optimization = False


# Multiple optimizers (e.g.: GANs)
def training_step(self, batch, batch_idx):
    opt1, opt2 = self.optimizers()

    # do training_step with encoder
    ...
    opt1.step()
    # do training_step with decoder
    ...
    opt2.step()
</code></pre>
<h2 id="note">Note</h2>
<p>When <code>accumulate_grad_batches</code> &gt; 1, the loss returned here will be automatically
normalized by <code>accumulate_grad_batches</code> internally.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.modules.text" href="index.html">src.modules.text</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.modules.text.vmmd_lightning.VMMDLightningBase" href="#src.modules.text.vmmd_lightning.VMMDLightningBase">VMMDLightningBase</a></code></h4>
<ul class="">
<li><code><a title="src.modules.text.vmmd_lightning.VMMDLightningBase.configure_optimizers" href="#src.modules.text.vmmd_lightning.VMMDLightningBase.configure_optimizers">configure_optimizers</a></code></li>
<li><code><a title="src.modules.text.vmmd_lightning.VMMDLightningBase.device" href="#src.modules.text.vmmd_lightning.VMMDLightningBase.device">device</a></code></li>
<li><code><a title="src.modules.text.vmmd_lightning.VMMDLightningBase.generate_subspaces" href="#src.modules.text.vmmd_lightning.VMMDLightningBase.generate_subspaces">generate_subspaces</a></code></li>
<li><code><a title="src.modules.text.vmmd_lightning.VMMDLightningBase.load_models" href="#src.modules.text.vmmd_lightning.VMMDLightningBase.load_models">load_models</a></code></li>
<li><code><a title="src.modules.text.vmmd_lightning.VMMDLightningBase.model_snapshot" href="#src.modules.text.vmmd_lightning.VMMDLightningBase.model_snapshot">model_snapshot</a></code></li>
<li><code><a title="src.modules.text.vmmd_lightning.VMMDLightningBase.training_step" href="#src.modules.text.vmmd_lightning.VMMDLightningBase.training_step">training_step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
